const fs = require("fs-extra");
import { normalize_code } from "./utils/normalize";
import { hash } from "./utils/hash";
const zlib = require("zlib");
import { save_script } from "./script";
import { load_event } from "./load_event";

interface SaveEventDetails {
    parent: { name: string, uid: string }
    entitytype: string
    language: string
    basetype?: 'AnimatedSprite' | 'Text' | 'BitmapText' | 'NineSlicePlane' | 'Container' |  'Button' | 'SpritedCounter' | 'RepeatingTexture' | 'TextBox'
}

interface CtCommon {
    _lastmod?: number
    _can_switch?: boolean
    _switched?: boolean
    last?: string
    hash?: string
}

export interface CtEvent extends CtCommon {
    eventKey: string
    fnKey?: string
    code?: string
    locals?: Record<string, { type: string }>
}

export interface CtScript extends CtCommon {
    uid?: string
}

export function safeClassName(name: string, _entitytype: string) {
    const result = name.replace(/[^a-z|A-Z|0-9]/g, "");
    return (result.match(/^[0-9]/)) ? `C${result}` : result;
}

export function findClosingBracket(lines: string[], startIndex: number) {
    let openBrackets = 0;
    for (let i = startIndex; i < lines.length; i++) {
        const line = lines[i];
        openBrackets += (line.match(/{/g) || []).length;
        openBrackets -= (line.match(/}/g) || []).length;
        if (openBrackets === 0) {
            return i;
        }
    }
    return -1
}

export async function save_event_ts(path: string, code: string, event: CtEvent, opts: SaveEventDetails) {
    const baseClass = opts.basetype || (opts.entitytype === 'room' ? 'Room' : 'Copy');
    const eventKey = event.fnKey || (event.eventKey[0].toLowerCase() + event.eventKey.slice(1));
    let contentBefore =
        '// This class is generated by ct.js - feel free to modify its methods but please\n' +
        '// leave the /* end  ... */ comments and method signature lines intact.\n' +
        '// You cannot add methods or imports to this file.\n\n' +
        `class ${safeClassName(opts.parent.name, opts.entitytype)} extends ${baseClass} {\n\n`;
    let functionDeclare = `    ${eventKey}(${event.locals ?
            Object.keys(event.locals).map((key) => `${key}: ${event.locals![key].type}`).join(', ')
        : ''}) {\n        `;
    let functionClose = `\n    } /* end ${eventKey} */\n`;
    let contentAfter = `\n} /* end ${opts.parent.uid} */\n`;
    if (await fs.pathExists(path)) {
        const existingContent = normalize_code(await fs.readFile(path, 'utf8'));
        if (existingContent.indexOf('class') === -1 &&
            existingContent.indexOf('function') === -1 &&
            existingContent.replace(/[\r\n \t]/g, '').length < 10) {
            /* Edge case 1: the file is nearly empty */
        }
        else {
            const functionStartRegex = new RegExp(`^${eventKey}\\s*\\(`);
            const functionEndRegex = new RegExp(`^.*\\/\\*\\s*end\\s*${eventKey}\\s*\\*\\/`);
            const classEndRegex = new RegExp(`^.*\\/\\*\\s*end\\s*${opts.parent.uid}\\s*\\*\\/`);
            const lines = existingContent.split('\n');
            const classDeclIndex = lines.findIndex(line => line.match(/^class +[A-Z|a-z|0-9]/));
            if (classDeclIndex > -1 && lines[classDeclIndex].match(/^class +[A-Z|a-z|0-9]+ +extends +[A-Z|a-z|0-9]+ +{ */)) {
                lines[classDeclIndex] = `class ${safeClassName(opts.parent.name, opts.entitytype)} extends ${baseClass} {`;
            }
            let startIndex = lines.findIndex(line => functionStartRegex.test(line.trim()));
            let endIndex = lines.findIndex(line => functionEndRegex.test(line.trim()));
            if (startIndex > -1 && endIndex > -1) {
                contentBefore = lines.slice(0, startIndex).join('\n') + '\n';
                contentAfter = lines.slice(endIndex + 1).join('\n');
            }
            else if (startIndex > -1 && endIndex === -1) {
                console.warn(`Warning: No closing bracket comment found for ${eventKey} in ${path}`);
                endIndex = findClosingBracket(lines, startIndex);
                if (endIndex === -1) {
                    /* Edge case 2: the file is syntactically incorrect */
                }
                else {
                    contentAfter = lines.slice(endIndex + 1).join('\n');
                }
            }
            else {
                startIndex = lines.findIndex(line => classEndRegex.test(line.trim()));
                if (startIndex === -1) {
                    console.warn(`Warning: No closing bracket comment found for ${opts.parent.uid} in ${path}`);
                    startIndex = lines.slice().reverse().findIndex(line => line.indexOf('}') > -1);
                    if (startIndex === -1) {
                        /* Edge case 3: the file is probably not typescript */
                        await fs.move(path, path + '.unknown');
                    }
                    else {
                        startIndex = lines.length - startIndex - 1;
                    }
                }
                contentBefore = lines.slice(0, startIndex).join('\n') + '\n';
            }
        }
    }
    const savedCode = normalize_code(code.trim());
    const fullContent = contentBefore + functionDeclare +
        savedCode.replace(/\n/g, '\n        ') + functionClose + contentAfter;
    event._lastmod = Number(new Date()) + 100;
    await fs.outputFile(path, fullContent, 'utf8');
    return savedCode;
}

export async function save_event_coffee(path: string, code: string, event: CtEvent, opts: SaveEventDetails) {
    let contentBefore =
        `# This file is generated by ct.js - feel free to modify its methods\n` +
        `# ${opts.parent.name} (${opts.entitytype}${opts.basetype ? `/${opts.basetype}` : ''})\n\n`;
    let contentAfter = '\n';
    const eventKey = event.fnKey || (event.eventKey[0].toLowerCase() + event.eventKey.slice(1));
    let functionDeclare = `${eventKey} = (${event.locals ?
            Object.keys(event.locals).map((key) => `${key}: ${event.locals![key].type}`).join(', ')
        : ''}) ->\n    `;

    if (await fs.pathExists(path)) {
        const existingContent = normalize_code(await fs.readFile(path, 'utf8'));
        const functionStartRegex = new RegExp(`^${eventKey}\\s*=\\s*\\(`);
        const functionEndRegex = /^[^\s]/;
        const lines = existingContent.split('\n');
        if (lines[1].indexOf('#') === 0) {
            lines[1] = `# ${opts.parent.name} (${opts.entitytype}${opts.basetype ? `/${opts.basetype}` : ''})`;
        }
        const startIndex = lines.findIndex(line => functionStartRegex.test(line));
        if (startIndex > -1) {
            const endIndex = lines.findIndex((line, i) => i > startIndex && functionEndRegex.test(line));
            if (endIndex === -1) {
                /* Case 1: the function is found and belongs at the end of the file */
                contentBefore = lines.slice(0, startIndex).join('\n') + '\n';
            }
            else {
                /* Case 2: the function in the middle of the file */
                contentBefore = lines.slice(0, startIndex).join('\n') + '\n';
                contentAfter = '\n' + lines.slice(endIndex - 1).join('\n');
            }
        }
        else {
            /* Case 3: the function is not found belongs at the end of the file */
            contentBefore = lines.join('\n') + '\n';
        }
    }
    const savedCode = normalize_code(code.trim());
    const fullContent = contentBefore + functionDeclare + savedCode.replace(/\n/g, '\n    ') + contentAfter;
    event._lastmod = Number(new Date()) + 100;
    await fs.outputFile(path, fullContent, 'utf8');
    return savedCode;
}

/**
 * Saves an event to the file system. If the event is switched (that is a recovery version not the
 * main one) it saves the code like a script to a file such as "spaceship.ts.onCreate.ictvers").
 * For events saved to the main file it tries to create a legitimate TypeScript or CoffeeScript
 * file with all events belonging to that room or copy.
 *
 * This is the heart of ct-files as these files can be easily parsed by AI and version control
 * systems. They can also be edited by advanced developers and can help with the cognitive
 * complexity of larger projects. Finally it solves [this issue](http://github.com/ct-0js/ct-js-old/issues/122)
 * allowing easy searching of code.
 *
 * @param path the path to the event file (e.g. "spaceship.ts") - never the ".ictvers" version
 * @param code the code to save
 * @param event the event metadata (largely only to update the _lastmod field)
 * @param opts a collection of related information including the parent name, entitytype and language
 * @returns a promise that resolves to the saved content (line endings and tabs may have changed)
 *          or undefined if the code was not saved (e.g. Catnip is kept in the project file)
 */
export async function save_event(path: string, code: string, event: CtEvent, opts: SaveEventDetails) {
    const eventKey = event.fnKey || (event.eventKey[0].toLowerCase() + event.eventKey.slice(1));

    if (event._switched) {
        return save_script(`${path}.${eventKey}`, code, event);
    }
    else if (opts.language === 'typescript') {
        return save_event_ts(path, code, event, opts);
    }
    else if (opts.language === 'coffeescript') {
        return save_event_coffee(path, code, event, opts);
    }
    else {
        return undefined;
    }
}

/**
 * Saves and commits an event to the file system. This is similar to save_event() but it also
 * removes any previous versions of the event (i.e. ".ictvers" files). And saves a compressed
 * version of the code to the project that can be restored at will.
 *
 * @param path the path to the event file (e.g. "spaceship.ts") - never the ".ictvers" version
 * @param code the code to save
 * @param event the event metadata (largely only to update the _lastmod field)
 * @param opts a collection of related information including the parent name, entitytype and language
 * @returns a promise that resolves to the saved content (line endings and tabs may have changed)
 *          or undefined if the code was not saved (e.g. Catnip is kept in the project file)
 */
export async function save_and_commit_event(path: string, code: string, event: CtEvent, opts: SaveEventDetails) {
    if (await fs.pathExists(`${path}.${event.eventKey}.ictvers`))
        await fs.remove(`${path}.${event.eventKey}.ictvers`);
    event._switched = false;
    event._can_switch = false;

    const result = await save_event(path, code, event, opts);

    if (result) {
        const compressedScript = zlib.deflateSync(result).toString('base64');
        event.last = compressedScript;
        event.hash = hash(result);
    }

    return result;
}

/**
 * In practice all events are committed at once - not individually. This loads each event and
 * then saves and commits them sequentially.
 *
 * @param path the path to the event file (e.g. "spaceship.ts") - never the ".ictvers" version
 * @param code the code to save
 * @param event the event metadata (largely only to update the _lastmod field)
 * @param opts a collection of related information including the parent name, entitytype and language
 * @returns a promise that resolves to an array of the saved content (line endings and tabs may
 *           have changed).
 */
export async function save_and_commit_all_events(path: string, events: CtEvent[], opts: SaveEventDetails) {
    const allCodePromises = events.map(async (event) => {
        let code = event.code;
        if (event.code === undefined) {
            code = await load_event(path, event, opts.language, 'compile');
        }
        return { code, event };
    });
    const allCode = await Promise.all(allCodePromises);
    for (let i = 0; i < events.length; i++) {
        const { code, event } = allCode[i];
        if (code === undefined) continue;
        await save_and_commit_event(path, code, event, opts);
    }
    return allCode;
}
