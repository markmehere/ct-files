"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.save_and_commit_all_events = exports.save_and_commit_event = exports.save_event = exports.save_event_coffee = exports.save_event_ts = exports.findClosingBracket = exports.safeClassName = void 0;
const fs = require("fs-extra");
const normalize_1 = require("./utils/normalize");
const hash_1 = require("./utils/hash");
const zlib = require("zlib");
const script_1 = require("./script");
const load_event_1 = require("./load_event");
function safeClassName(name, _entitytype) {
    const result = name.replace(/[^a-z|A-Z|0-9]/g, "");
    return (result.match(/^[0-9]/)) ? `C${result}` : result;
}
exports.safeClassName = safeClassName;
function findClosingBracket(lines, startIndex) {
    let openBrackets = 0;
    for (let i = startIndex; i < lines.length; i++) {
        const line = lines[i];
        openBrackets += (line.match(/{/g) || []).length;
        openBrackets -= (line.match(/}/g) || []).length;
        if (openBrackets === 0) {
            return i;
        }
    }
    return -1;
}
exports.findClosingBracket = findClosingBracket;
function save_event_ts(path, code, event, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const baseClass = opts.basetype || (opts.entitytype === 'room' ? 'Room' : 'Copy');
        const eventKey = event.fnKey || (event.eventKey[0].toLowerCase() + event.eventKey.slice(1));
        let contentBefore = '// This class is generated by ct.js - feel free to modify its methods but please\n' +
            '// leave the /* end  ... */ comments and method signature lines intact.\n' +
            '// You cannot add methods or imports to this file.\n\n' +
            `class ${safeClassName(opts.parent.name, opts.entitytype)} extends ${baseClass} {\n\n`;
        let functionDeclare = `    ${eventKey}(${event.locals ?
            Object.keys(event.locals).map((key) => `${key}: ${event.locals[key].type}`).join(', ')
            : ''}) {\n        `;
        let functionClose = `\n    } /* end ${eventKey} */\n`;
        let contentAfter = `\n} /* end ${opts.parent.uid} */\n`;
        if (yield fs.pathExists(path)) {
            const existingContent = (0, normalize_1.normalize_code)(yield fs.readFile(path, 'utf8'));
            if (existingContent.indexOf('class') === -1 &&
                existingContent.indexOf('function') === -1 &&
                existingContent.replace(/[\r\n \t]/g, '').length < 10) {
                /* Edge case 1: the file is nearly empty */
            }
            else {
                const functionStartRegex = new RegExp(`^${eventKey}\\s*\\(`);
                const functionEndRegex = new RegExp(`^.*\\/\\*\\s*end\\s*${eventKey}\\s*\\*\\/`);
                const classEndRegex = new RegExp(`^.*\\/\\*\\s*end\\s*${opts.parent.uid}\\s*\\*\\/`);
                const lines = existingContent.split('\n');
                const classDeclIndex = lines.findIndex(line => line.match(/^class +[A-Z|a-z|0-9]/));
                if (classDeclIndex > -1 && lines[classDeclIndex].match(/^class +[A-Z|a-z|0-9]+ +extends +[A-Z|a-z|0-9]+ +{ */)) {
                    lines[classDeclIndex] = `class ${safeClassName(opts.parent.name, opts.entitytype)} extends ${baseClass} {`;
                }
                let startIndex = lines.findIndex(line => functionStartRegex.test(line.trim()));
                let endIndex = lines.findIndex(line => functionEndRegex.test(line.trim()));
                if (startIndex > -1 && endIndex > -1) {
                    contentBefore = lines.slice(0, startIndex).join('\n') + '\n';
                    contentAfter = lines.slice(endIndex + 1).join('\n');
                }
                else if (startIndex > -1 && endIndex === -1) {
                    console.warn(`Warning: No closing bracket comment found for ${eventKey} in ${path}`);
                    endIndex = findClosingBracket(lines, startIndex);
                    if (endIndex === -1) {
                        /* Edge case 2: the file is syntactically incorrect */
                    }
                    else {
                        contentAfter = lines.slice(endIndex + 1).join('\n');
                    }
                }
                else {
                    startIndex = lines.findIndex(line => classEndRegex.test(line.trim()));
                    if (startIndex === -1) {
                        console.warn(`Warning: No closing bracket comment found for ${opts.parent.uid} in ${path}`);
                        startIndex = lines.slice().reverse().findIndex(line => line.indexOf('}') > -1);
                        if (startIndex === -1) {
                            /* Edge case 3: the file is probably not typescript */
                            yield fs.move(path, path + '.unknown');
                        }
                        else {
                            startIndex = lines.length - startIndex - 1;
                        }
                    }
                    contentBefore = lines.slice(0, startIndex).join('\n') + '\n';
                }
            }
        }
        const savedCode = (0, normalize_1.normalize_code)(code.trim());
        const fullContent = contentBefore + functionDeclare +
            savedCode.replace(/\n/g, '\n        ') + functionClose + contentAfter;
        event._lastmod = Number(new Date()) + 100;
        yield fs.outputFile(path, fullContent, 'utf8');
        return savedCode;
    });
}
exports.save_event_ts = save_event_ts;
function save_event_coffee(path, code, event, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        let contentBefore = `# This file is generated by ct.js - feel free to modify its methods\n` +
            `# ${opts.parent.name} (${opts.entitytype}${opts.basetype ? `/${opts.basetype}` : ''})\n\n`;
        let contentAfter = '\n';
        const eventKey = event.fnKey || (event.eventKey[0].toLowerCase() + event.eventKey.slice(1));
        let functionDeclare = `${eventKey} = (${event.locals ?
            Object.keys(event.locals).map((key) => `${key}: ${event.locals[key].type}`).join(', ')
            : ''}) ->\n    `;
        if (yield fs.pathExists(path)) {
            const existingContent = (0, normalize_1.normalize_code)(yield fs.readFile(path, 'utf8'));
            const functionStartRegex = new RegExp(`^${eventKey}\\s*=\\s*\\(`);
            const functionEndRegex = /^[^\s]/;
            const lines = existingContent.split('\n');
            if (lines[1].indexOf('#') === 0) {
                lines[1] = `# ${opts.parent.name} (${opts.entitytype}${opts.basetype ? `/${opts.basetype}` : ''})`;
            }
            const startIndex = lines.findIndex(line => functionStartRegex.test(line));
            if (startIndex > -1) {
                const endIndex = lines.findIndex((line, i) => i > startIndex && functionEndRegex.test(line));
                if (endIndex === -1) {
                    /* Case 1: the function is found and belongs at the end of the file */
                    contentBefore = lines.slice(0, startIndex).join('\n') + '\n';
                }
                else {
                    /* Case 2: the function in the middle of the file */
                    contentBefore = lines.slice(0, startIndex).join('\n') + '\n';
                    contentAfter = '\n' + lines.slice(endIndex - 1).join('\n');
                }
            }
            else {
                /* Case 3: the function is not found belongs at the end of the file */
                contentBefore = lines.join('\n') + '\n';
            }
        }
        const savedCode = (0, normalize_1.normalize_code)(code.trim());
        const fullContent = contentBefore + functionDeclare + savedCode.replace(/\n/g, '\n    ') + contentAfter;
        event._lastmod = Number(new Date()) + 100;
        yield fs.outputFile(path, fullContent, 'utf8');
        return savedCode;
    });
}
exports.save_event_coffee = save_event_coffee;
/**
 * Saves an event to the file system. If the event is switched (that is a recovery version not the
 * main one) it saves the code like a script to a file such as "spaceship.ts.onCreate.ictvers").
 * For events saved to the main file it tries to create a legitimate TypeScript or CoffeeScript
 * file with all events belonging to that room or copy.
 *
 * This is the heart of ct-files as these files can be easily parsed by AI and version control
 * systems. They can also be edited by advanced developers and can help with the cognitive
 * complexity of larger projects. Finally it solves [this issue](http://github.com/ct-0js/ct-js-old/issues/122)
 * allowing easy searching of code.
 *
 * @param path the path to the event file (e.g. "spaceship.ts") - never the ".ictvers" version
 * @param code the code to save
 * @param event the event metadata (largely only to update the _lastmod field)
 * @param opts a collection of related information including the parent name, entitytype and language
 * @returns a promise that resolves to the saved content (line endings and tabs may have changed)
 *          or undefined if the code was not saved (e.g. Catnip is kept in the project file)
 */
function save_event(path, code, event, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const eventKey = event.fnKey || (event.eventKey[0].toLowerCase() + event.eventKey.slice(1));
        if (event._switched) {
            return (0, script_1.save_script)(`${path}.${eventKey}`, code, event);
        }
        else if (opts.language === 'typescript') {
            return save_event_ts(path, code, event, opts);
        }
        else if (opts.language === 'coffeescript') {
            return save_event_coffee(path, code, event, opts);
        }
        else {
            return undefined;
        }
    });
}
exports.save_event = save_event;
/**
 * Saves and commits an event to the file system. This is similar to save_event() but it also
 * removes any previous versions of the event (i.e. ".ictvers" files). And saves a compressed
 * version of the code to the project that can be restored at will.
 *
 * @param path the path to the event file (e.g. "spaceship.ts") - never the ".ictvers" version
 * @param code the code to save
 * @param event the event metadata (largely only to update the _lastmod field)
 * @param opts a collection of related information including the parent name, entitytype and language
 * @returns a promise that resolves to the saved content (line endings and tabs may have changed)
 *          or undefined if the code was not saved (e.g. Catnip is kept in the project file)
 */
function save_and_commit_event(path, code, event, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (yield fs.pathExists(`${path}.${event.eventKey}.ictvers`))
            yield fs.remove(`${path}.${event.eventKey}.ictvers`);
        event._switched = false;
        event._can_switch = false;
        const result = yield save_event(path, code, event, opts);
        if (result) {
            const compressedScript = zlib.deflateSync(result).toString('base64');
            event.last = compressedScript;
            event.hash = (0, hash_1.hash)(result);
        }
        return result;
    });
}
exports.save_and_commit_event = save_and_commit_event;
/**
 * In practice all events are committed at once - not individually. This loads each event and
 * then saves and commits them sequentially.
 *
 * @param path the path to the event file (e.g. "spaceship.ts") - never the ".ictvers" version
 * @param code the code to save
 * @param event the event metadata (largely only to update the _lastmod field)
 * @param opts a collection of related information including the parent name, entitytype and language
 * @returns a promise that resolves to an array of the saved content (line endings and tabs may
 *           have changed).
 */
function save_and_commit_all_events(path, events, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const allCodePromises = events.map((event) => __awaiter(this, void 0, void 0, function* () {
            let code = event.code;
            if (event.code === undefined) {
                code = yield (0, load_event_1.load_event)(path, event, opts.language, 'compile');
            }
            return { code, event };
        }));
        const allCode = yield Promise.all(allCodePromises);
        for (let i = 0; i < events.length; i++) {
            const { code, event } = allCode[i];
            if (code === undefined)
                continue;
            yield save_and_commit_event(path, code, event, opts);
        }
        return allCode;
    });
}
exports.save_and_commit_all_events = save_and_commit_all_events;
